\subsection{Divider}


The algorithm implemented in the original version of the processor is one of the simplest but the
slowest available: a radix-2 non restoring division.

Several other algorithms can compute the division faster but all of them present disadvantages
that must be taken into account according to the target application.

Algorithms like repeated multiplication or reciprocation are fast but require a significant amount
of area because they require a whole multiplier to work which is alone a pretty big circuit.
Similarly an array divider would have been very fast only If we had control on the
place\&routing process in order to create a regular structure, something that in FPGAs we cannot control so we discarded that option. 

In the end we decided to implement
a simple radix-4 division algorithm for simplicity of implementation and of the circuit itself.

Using an higher radix could have improved performance but the size of the lookup table required
by the algorithm would have increased again the area consumption.
The area itself is not a big problem since as we said we care more about power consumption and execution time, but a larger circuit means also harder computations and so more energy consumption.

The divider consist in a state machine (its diagram is shown in figure~\ref{fig:div_state_dia}) which checks if the inputs will
generate an overflow by doing a trial subtraction between the divisor and the MSBs of the dividend, and performs a preliminary shift to put the divisor in the appropriate range in order to match the right range for the look-up table to work.


\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth,height=0.4\textheight,keepaspectratio]{DivisorStateMachine.png}
\caption{Divider State Diagram.}
\label{fig:div_state_dia}
\end{figure}

In the figure above is shown also when the ready signals are asserted, from the documentation we see that the ready signal must be set the cycle before the result is stable so in the last state of the state machine because once the machine returns in the idle state the registers are "freezed" and so the results is stable, and the nready signal must be asserted 3 cycles before the results is stable, and after doing some math this cycle is when during the core computation the counter's value is 14 ("1110"). 
By observing these signals the integer unit can find out when the operation is finished in order to eventually fetch another instruction or to make the pipeline go one step further.

After that, the real computation begins and lasts 16 clock cycles. The block diagram of the divider
while it's in this state is shown in figure~\ref{fig:div_block_dia}.

\begin{figure}[H]
\centering
\includegraphics[width=1.5\textwidth,height=0.4\textheight,keepaspectratio]{DivisorDiagram.png}
\caption{Divider Block Diagram (during Core Computation, State = 1).}
\label{fig:div_block_dia}
\end{figure}

The algorithm is very similar to the original radix-2 version but in this case the partial reminder (x)
is shifted by 2 bits every cycle and the circuit has to guess the quotient digit from the range [-3,3].
``qSelector'' is the lookup table which performs the quotient digit guessing and it's based on the p-
d plot of the radix-4 SRT division shown in figure~\ref{fig:div_pd_plot}. In case of unsigned division only the right half of
the p-d plot is being used.

The quotient digits are in a radix-4 redundant format so a conversion to binary format is needed.
The conversion is performed gradually every cycle by the 32-bit adder ``CPAq'' which shift and sum
each generated digit with the already calculated quotient.

An addition/subtraction in Carry-Save format would have been much faster and also easier for both the quotient and the partial reminder, but the selection of the quotient digit would have required the analysis of the most significant bits of
both the sum and the carry of the reminder (x) making the lookup table several orders of magnitude bigger and so consuming lots of area.
In our divider ``SubGen'' generates the multiple of d to sum with the current partial reminder in a
carry save format, all this operands are being compressed by a 3-2 compressor (1 full adder of
delay) and finally the new partial reminder is calculated with a 35-bit adder, ``CPAx''. Using this architecture is possible to calculate easely the triple multiples of d allowing us to have a simpler p-d plot and so a smaller look-up table, in particular the -3d, which is the most difficult, is calculated as the negate of 2d concatenated with a 1 plus the negate of d and the signal t is setted to 1 so that can be summed twice in the compressor and as the carry input of CPAx, in this way its weight is 2 and so can complete the calculation of the 2s complement of 2d.

The principle behind the calculation of the multiples is explained better in figure~\ref{fig:div_subGen}.

\begin{figure}[H]
\centering
\includegraphics[width=0.85\textwidth,height=0.85\textheight,keepaspectratio]{radix4pd.png}
\caption{Radix-4 P-D Plot (Red Dots are Exceptions).}
\label{fig:div_pd_plot}
\end{figure}

\begin{figure}[H]
\centering
\includegraphics[width=1.5\textwidth,height=0.5\textheight,keepaspectratio]{SubGenExplanation.png}
\caption{Detail of SubGen (d multiples generator based of the qDigit).}
\label{fig:div_subGen}
\end{figure}

Other solutions have been analyzed, such as having a lookup table only for unsigned division, half
of the size of the final version, and handle the sign separately but the synthesis has shown that the
resources utilization would have not changed significantly while one more cycle would have been needed.
Hence, we decided to keep the current divider.

At last, in order to check the compatibility of the radix-4 divider with the rest of the system, and its correct functioning, we designed a testbench.
In this testbench we placed both the old version and the new version of the divider and the inputs are routed to the two units equally, we expect to have the same outputs but in a shorter time.
Of course it's prohibitive to test the unit for each possible inputs so we found a set of critical operations.
There are some categories of operations in this case, simple signed/unsigned division such as 350/100 or -350/100 which can be performed with the signed signal asserted or not, operations involving exceptions in the p-d plot, and operations generating overflows.
The first category is not critical but just to be sure and have a complete testbench we implemented some of them.
As shown in figure~\ref{fig:div_pd_plot}, there are a couple of exceptions in the p-d plot. These exceptions are handled by the qSelector apart from all the other cases with dedicated lines of code (simple ifs).
For instance one of these exceptions is when the divisor is "0100" and the dividend is "111000" followed by all zeros (otherwise it would not be an exception because the point would be inside the uncertanties area and not in the bottom left corner), in this case the quotient digit must be -2 instead of -1 so one of these operations could be simply -16/4, for this operation after the pre-shift the input of qSelector would be exactly these ones.
For the operations involving overflows there are several possibilities where the dividend is very high and the divisor very low, enough to make the result greater than 2\textsuperscript{32}. There are also some operations that when considered to be signed don't generate overflows while if unsigned they do. This happen when the most significant bit of the dividend is one, its weight is 2\textsuperscript{63} when unsigned and -2\textsuperscript{64} when signed and so it can change a lot the absolute value of the result.

All of this kind of operations have been analyzed in a testbench, a part of it in figure~\ref{fig:div32_wave}, and the result is always the same as the baseline version of the divider. The only different thing is that when there is an overflow the result of the radix-4 divider is different from the baseline, sometimes the simulator puts it as "X" because in an overflow the qSelector works in some of the not allowed areas, but the overflow flag is asserted normally so the processor won't consider the actual result and so this is not a problem.

\begin{figure}[H]
\centering
\includegraphics[width=1.2\textwidth,height=0.8\textheight,keepaspectratio]{myDivisionvsOriginal.png}
\caption{Signal Dump Of Radix-4 Divider Vs. Original Divider.}
\label{fig:div32_wave}
\end{figure}
