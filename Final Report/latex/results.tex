\renewcommand{\kHz}{\si{\kHz}\xspace}
\renewcommand{\MHz}{\si{\MHz}\xspace}
\renewcommand{\W}{\si{\W}\xspace}
\renewcommand{\s}{\si{\s}\xspace}
\newcommand{\Oppers}{~\si[per-mode=symbol]{Op\per\s}\xspace}


\section{Results}
\label{sec:results}
\subsection{Synthesis}

In order to evaluate the performance of our improved processor we need first to play close attention to the starting point: the
performance of the baseline version of the processor.

The evaluation of each design will be divided in two main categories
\begin{itemize}
\item Resources' Utilization (provided by Xilinx ISE)
\item Benchmarks' Results (provided by the FPGA server)
\end{itemize}

The synthesis tool reported the values shown in table~\ref{tbl:resource_utilization} for the resources utilization.
Results for four different configurations are present which will allow us to better understand the impact of each modification in the area and power consumption.
These are the baseline design, the design with the modified multiplier and original divider, modified divider and original divider and finally with both units modified. 

One metric that is particularly interesting is ``P/f'' which reflects the energy efficiency of the processor. Another useful insight is the fact that the power consumption is almost proportional to the clock frequency, therefore we can use this value to estimate the power consumption at different clock frequencies.

In addition, from the synthesis report we can also see the slowest path which determines the max clock frequency.
This path is from \url{ddrsp0.ddrc0/ddr32.ddrc/ra.raddr_0} to \url{ddrsp0.ddrc0/ddr_phy0/ddr_phy0/xc4v.ddr_phy0/casgen}.

Those components belong to the SDRAM controller and the path is located between the controller
and the physical interface with the memory.

The cummulative synthesis report with the aforementioned four configurations is summarized in table~\ref{tbl:resource_utilization}:

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
 & Baseline & Multiplier & Divider & Both\\% & Improvements\\
\midrule
Max clk freq. [\MHz] & 80.522 & 80.019 & 80.535 & 80.205\\% & \color{red} -0.39 \%\\
\# of Occupied Slices & 9904 &  10226 &  10479 & 10773\\% & \color{red} 8.77 \%\\
Total \# of 4-input LUTs & 16889 & 17398 & 17865 & 18329\\% & \color{red} 8.53 \%\\
Quiescent power [\W] & 2.467 &  2.467 & 2.468 & 2.469\\% & \color{red} 0.08 \%\\
Dynamic power [\W] & 0.721 &  0.726 & 0.743 & 0.756\\% & \color{red} 4.85 \%\\
Total power [\W] & 3.188 &  3.193 & 3.211 & 3.225\\% & \color{red} 1.16 \%\\
P/f [\si[per-mode=symbol]{\W\per\MHz}] & 0.03959 & 0.03990 & 0.03987 & 0.04021% & \color{red} 1.57 \%\\\toprule
\end{tabular}
\caption{Resource Utilization}
\label{tbl:resource_utilization}
\end{table}

The frequency does not suffer considerable variations.

As expected the area consumption is moderately higher than before as the units we designed are more complex than the baseline. In particular the lookup table in the divider, and the Wallace tree structure in the multiplier are very space-hungry. This is reflected when comparing the last and second column, with area expansion of around 8\%.

Furthermore the power consumption also augments. However the differences are more subtle, varying between 0.1\% and 4.9\%. The reason is similar, since the algorithms are more complicated more energy is expended for all the calculations. However this trade-off was envisioned at the start of the project, and as we will see later, in section~\ref{ssec:benchmarks}, the benchmark's performance improved.

Finally the power frequecy ratio summarizes the points made above. Since the power consumption is higher and the frequency is more or less the same, this metric will increase, although not too significantly.


\subsection{Benchmark Scores}
\label{ssec:benchmarks}

Once the processor is synthesized and has been loaded in a FPGA board, Linux is initiated on the processor along with several benchmarks. In table~\ref{tbl:benchmarks} the execution times of these benchmarks are reported, for detailed scores please see the accompanying Excel file. Unfortunaly we were not able to obtain results when uploading the multiplier only design (original divider) to the FPGA. This is strange as this multiplier unit worked before, in combination with the rewritten divider. Given this evidence we suspect the problem lays with the FPGA and not with the multiplier unit.

\begin{table}[H]
\centering
\begin{tabular}{lcccc}
 & Baseline & Divider & Both \\
\midrule

Stanford [\s] & 2.30 & 2.26 & 2.23\\
Whetstone [\s] & 116.2 & 113.25 & 111.61\\
Gmpbench Multiply [\Oppers] & 781 & 801 & 912\\
Gmpbench Divide [\Oppers] & 15876 & 16335 & 19205\\
Gmpbench RSA [\Oppers] & 5123 & 5284 & 5353\\
Division [\s] & 8.06 & 7.65 & 7.31\\
Mibench JPEG (average) [\s] & 23.215 & 22.465 & 21.815\\
SSD [\s] & 10.59 & 10.21 & 8.69\\
Total [\s] & 219.28 & 203.30 & 207.06
\end{tabular}
\caption{Benchmarks Scores.}
\label{tbl:benchmarks}
\end{table}

The scores obtained with the modified processor are reported in table~\ref{tbl:benchmarks}. As one can see introducing the divider has a widespread positive effect on the scores. The same can be said about the multiplier. Analyzing these results with respect to the worst area and power performance will be left for section~\ref{ssec:metrics}.

From these results we can see that almost every benchmark had a healthy improvement, in the end
the total execution time improved by 5.6\%.
It is interesting to observe that both units yield improvements to the benchmark scores.
However for the total execution time introducing the multiplier has a detrimental effect.
This is counter-intuitive given there were improvements in all the individual benchmark scores.
\textcolor{red}{\large The reason for this behavior is not clear to us.}

These scores are not as good as expected but likely the execution of the operating system
on the processor causes a non negligible overhead in the execution due to the scheduling. As an example, the
divider takes about half the time to execute but the execution time of the division related
benchmarks is only about 10\% better.

\subsection{Metrics Comparison}
\label{ssec:metrics}

In order to get a fair comparison between the baseline and the improved processor some standard
metrics have to be calculated and studied.

Usually these metrics are \texttt{A}, the area consumption here calculated as the weighted sum of the
number of occupied slices and the number of 4-input LUTs used where the weight is the reciprocal
of the number of available resources, \texttt{D} is the delay or the reciprocal of the maximum clock frequency
and indicate the delay of the slowest path, \texttt{P} is the power and it's simply calculated as the total
power consumed by the Dhrystone benchmark used for the simulation and \texttt{BS} is the benchmark
score which indicate how fast a program can be executed, it's calculated as the total execution
time of the benchmarks on the FPGA board.

For the area we are using the weighted formula to account for the true cost of our implementation instead of just the number of resources used.
We make the simplistic assumption that the number of resources available on the device is inversely proportional to their effective cost. Thus we use their reciprocal as a weight to calculate the average. Therefore we obtain a metric which is likely similar to the actual cost of the implementation on a chip.

Moreover some composite metrics can be observed. These metrics consider two or more primitive
metrics and are often more interesting than the latter because improvements in one metric are usually accompanied by decrease in other.
Thus composite metrics show the overall performance, and give insight on the necessary trade-offs.

Since we want to speed-up the execution of the software while keeping the power consumption
low as our target applications are embedded systems, the composite metric we are
interested the most is \texttt{P$\times$BS}. It reflects how much the processor is able to compute for the same unit of energy.

Additional composite metrics are \texttt{A$\times$D}, \texttt{A$\times$BS} and \texttt{P$\times$D}. Since we focused on the
execution time and power consumption one can notice that the other metrics are worse in our version
compared to the baseline.

All the baseline's and modified units' synthesis and benchmark results have been condensed in table~\ref{tbl:final_metrics}.

\begin{table}[H]
\centering

\resizebox{\textwidth}{!}{ %scales the font automagically to fit the maximum text width! Nice :)
\begin{tabular}{lcccc}
&
\multicolumn{4}{c}{Primitive Metrics}\\
&
\ttfamily A &
\ttfamily D &
\ttfamily P &
\ttfamily BS \\
Baseline &
\num{2.68E+04} &
\num{1.24E-02} &
\num{3.19E+00} &
\num{2.19E+02} \\
Modified (Div)&
\num{2.83E+04} &
\num{1.24E-02} &
\num{3.21E+00} &
\num{2.13E+02} \\
Modified (Mul\&Div)&
\num{2.91E+04} &
\num{1.25E-02} &
\num{3.23E+00} &
\num{2.07E+02} \\
Improvements (Div) &
\color{red} 5.8\% &
- &
\color{red} 0.7\% &
\color{green} -2.7\% \\
Improvements (Mul\&Div) &
\color{red} 8.6\% &
\color{red} 0.4\% &
\color{red} 1.2\% &
\color{green} -5.6\% \\

\\ \midrule \\

& \multicolumn{4}{c}{Composite Metrics}\\
&
\ttfamily A$\times$D &
\ttfamily A$\times$BS &
\ttfamily P$\times$D &
\ttfamily P$\times$BS\\
Baseline &
\num{3.33E+02} &
\num{5.88E+06} &
\num{3.96E-02} &
\num{6.99E+02} \\
Modified (Div)&
\num{3.52E+02} &
\num{6.05E+06} &
\num{3.99E-02} &
\num{6.85E+02} \\
Modified (Mul\&Div)&
\num{3.63E+02} &
\num{6.03E+06} &
\num{4.02E-02} &
\num{6.68E+02} \\
Improvements (Div) &
\color{red} 5.8\% &
\color{red} 2.9\% &
\color{red} 0.7\% &
\color{green} -2.0\% \\
Improvements (Mul\&Div)&
\color{red} 9\% &
\color{red} 2.6\% &
\color{red} 1.6\% &
\color{green} -4.5\%\\
\end{tabular}}
\caption{Final Metrics For Baseline And Improved Versions.}
\label{tbl:final_metrics}
\end{table}