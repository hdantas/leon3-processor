\renewcommand{\kHz}{\si{\kHz}\xspace}
\renewcommand{\MHz}{\si{\MHz}\xspace}
\renewcommand{\W}{\si{\W}\xspace}
\renewcommand{\s}{\si{\s}\xspace}
\newcommand{\Oppers}{~\si[per-mode=symbol]{Op\per\s}\xspace}


\section{Results}

\subsection{Synthesis}

In order to evaluate the performance of our improved processor we need first to evaluate the
performance of the baseline version of the processor.

The synthesis tool reported the values in the Table 1 for the resources utilization.

\begin{table}[H]
\centering
\begin{tabular}{c>{\color{white}\columncolor{Cyan}}c}
\bottomrule

Timing Summary (max clock freq. [\MHz]) & 80.522\\
\# of Occupied Slices & 9904\\
Total \# of 4-input LUTs & 16889\\
Quiescent power [\W] & 2.467\\
Dynamic power [\W] & 0.721\\
Total power [\W] & 3.188\\
P/f [\si[per-mode=symbol]{\W\per\MHz} ] & 0.03959\\\toprule
\end{tabular}
\caption{Resource Utilization Baseline.}
\label{tbl:resoutce_utilization}
\end{table}

Notice that the value ``P/f'' indicate the energetic efficiency of the processor, since the power
consumption is almost proportional to the clock frequency we can use this value to estimate the
power consumption at different clock frequencies.

From the synthesis report we can also see the slowest path which determines the max clock
frequency.

This path is from ``ddrsp0.ddrc0/ddr32.ddrc/ra.raddr\_0'' to ``ddrsp0.ddrc0/ddr\_phy0/ddr\_phy0/xc4v.ddr\_phy0/casgen''.


Those components belong to the SDRAM controller and the path is located between the controller
and the physical interface with the memory.

The synthesis of our modified version gave us the results showed in Table 2:


\begin{table}[H]
\centering
\begin{tabular}{c>{\color{white}\columncolor{Cyan}}c}
\bottomrule

Timing Summary (max clock freq. [\MHz]) & 40.197 \\
\# of Occupied Slices & 11886\\
Total \# of 4-input LUTs & 20469\\
Quiescent power [\W] & 2.511\\
Dynamic power [\W] & 0.832\\
Total power [\W] & 3.343\\
P/f [\si[per-mode=symbol]{\W\per\MHz}] & 0.08317\\\toprule
\end{tabular}
\caption{Resource Utilization Modified Version.}
\label{tbl:resoutce_utilization_modified}
\end{table}

As we expected the area consumption is quite worse because the unit we designed is way more
complex than the baseline, in particular the look-up table in the divider consumes lots of area.

Also the power consumption increased for the same reason, the algorithm is more complicated so
more energy is consumed to do all the calculations, but fortunately the disadvantage is negligible
compared to the advantage as it will be shown later.

The only parameter which is better is the max clock frequency achievable but probably this is only
due to the synthesis tool that rearranged the processor's component in a different way that is
better for the clock performance.

\subsection{Benchmark Scores}

Once the processor is synthesized has been loaded in a FPGA board, then Linux has been launched
on the processor as much as several benchmarks. In Table 3 the execution times of these
benchmarks are reported, for detailed scores see the excel file attached.

\begin{table}[H]
\centering
\begin{tabular}{c>{\color{white}\columncolor{Cyan}}c}
\bottomrule

Stanford [\s] & 2.30\\
Whetstone [\s] & 116.2\\
Gmpbench Multiply [\Oppers] & 781\\
Gmpbench Divide [\Oppers] & 15876\\
Gmpbench RSA [\Oppers] & 5123\\
Division [\s] & 8.06\\
Mibench JPEG (average) [\s] & 23.215\\
SSD [\s] & 10.59\\
Total [\s] & \textbf{219.28}\\
\toprule
\end{tabular}
\caption{Benchmarks Scores Baseline}
\label{tbl:benchmarks_baseline}
\end{table}

The scores obtained with the modified processor are reported in Table 4.

\begin{table}[H]
\centering
\begin{tabular}{c>{\color{white}\columncolor{Cyan}}c}
\bottomrule

Stanford [\s] & 2.21\\
Whetstone [\s] & 112.08\\
Gmpbench Multiply [\Oppers] & 914\\
Gmpbench Divide [\Oppers] & 19205\\
Gmpbench RSA [\Oppers] & 5353\\
Division [\s] & 7.31\\
Mibench JPEG (average) [\s] & 21.76\\
SSD [\s] & 8.60\\
Total [\s] & \textbf{206.92}\\
\toprule
\end{tabular}
\caption{Benchmarks Scores Modified Version}
\label{tbl:benchmarks_modified}
\end{table}

From these results we can see that almost every benchmark had a slight improvement, in the end
the total execution time improved by 2.7\%.

These scores are not as good as we expected but probably the execution of an operative system
on the processor cause a not negligible overhead in the execution due to the scheduling (the
divider takes about half the time to execute but the execution time of the division related
benchmarks is only about 10\% better).

\subsection{Metrics Comparison}

In order to get a fair comparison between the baseline and the improved processor some standard
metrics have to be calculated and studied.

Usually these metrics are \texttt{A}, the area consumption here calculated as the weighted sum of the
number of occupied slices and the number of 4-input LUTs used where the weight is the reciprocal
of the number of available resources, \texttt{D} is the delay or the reciprocal of the max clock frequency
and indicate the delay of the slowest path, \texttt{P} is the power and it's simply calculated as the total
power consumed by the Dhrystone benchmark used for the simulation and \texttt{BS} is the benchmark
score which indicate how fast a program can be executed, it's calculated as the total execution
time of the benchmarks on the FPGA board.

Moreover some composite metrics can be observed: these metrics consider two or more primitive
metrics and often are more interesting than these ones because when a modification is done on
the processor usually we obtain two opposite effects, one primitive metrics increases while
another one decreases, but what we want is that all in all we have an improvement. Composite
metrics show the overall performance.

Since we want to speed-up the execution of the software while keeping the power consumption
low because this is a processor designed for embedded applications, the composite metric we are
interested the most is \texttt{P$\times$BS} which show how much the processor is able to execute the software
fast with the same amount of energy.

Other composite metrics are \texttt{A$\times$D}, \texttt{A$\times$BS} and \texttt{P$\times$D}. Since we focused on the improvement of the
execution time and power consumption one can notice that these metrics are worse in our version
compared to the baseline, because the area consumption has increased notably and the delay
hadn't had any significant changes.

Both the baseline version's and our improved version's synthesis and benchmark results have be
condensed in this metrics and their values are in the Table 5.

\begin{table}[H]
\centering
\begin{tabular}{ccccc}

&
\multicolumn{4}{c}{Primitive Metrics}\\
Version &
\ttfamily A &
\ttfamily D &
\ttfamily P &
\ttfamily BS \\
Baseline &
\num{2.68E+04} &
\num{1.24E-02} &
\num{3.19E+00} &
\num{2.19E+02} \\
Modified &
\num{2.83E+04} &
\num{1.24E-02} &
\num{3.21E+00} &
\num{2.13E+02} \\
Improvements &
\color{green} 5.8\% &
- &
\color{green} 0.7\% &
\color{red} -2.7\% \\

\midrule

& \multicolumn{4}{c}{Composite Metrics}\\
Version &
\ttfamily A$\times$D &
\ttfamily A$\times$BS &
\ttfamily P$\times$D &
\ttfamily P$\times$BS\\
Baseline &
\num{3.33E+02} &
\num{5.88E+06} &
\num{3.96E-02} &
\num{6.99E+02} \\
Modified &
\num{3.52E+02} &
\num{6.05E+06} &
\num{3.99E-02} &
\num{6.85E+02} \\
Improvements &
\color{green} 5.8\% &
\color{green} 2.9\% &
\color{green} 0.7\% &
\color{red} -2.0\%\\
\end{tabular}
\caption{Final Metrics For Baseline And Improved Versions}
\label{tbl:final_metrics}
\end{table}