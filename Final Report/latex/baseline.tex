\section{Baseline Analysis and Working Plan}
\label{sec:baseline}
In order to find out which modifications will augment the processor's performance first an analysis of the baseline version is needed.
By looking at the documentation and the results of the synthesis of the baseline version we divided all the potential modifications in three categories:

\begin{itemize}
  \item Arithmetic improvements
  \item Clock frequency improvements
  \item Architectural improvements
\end{itemize}

As explained before, the SPARC V8 architecture used by the LEON3 processor contemplates several assembly instructions for complex operations such as multiplication and division.
The integer unit of the baseline version is equipped with 2 units that can execute hardware multiplications and divisions, but the performance in terms of execution time of these ones are quite poor.
Even if they do not occupy too much area with the default settings the multiplication takes 2 clock cycles and the division 36, advanced albeit simple algorithms can be implemented to significantly reduce the execution times.
Nonetheless, prior to implementing any improvement it is important to evaluate the corresponding gains with respect to the compound metric we elected as most significant: \texttt{P}$\times$\texttt{BS}.

Necessarily the complexity of the resulting circuits will increase and therefore so will the power consumption. However the baseline version's units are not particularly low power. They use carry propagate adders which are not very efficient in terms of power and path delay, thus there is room to improve these aspects and consequently reduce the weight of the power increase on the modified processor.

In addition it is relevant to study how often these instructions are used by an average program.
Assuming that the given benchmarks represent the average usage of the processor's resources, it's possible to see that the division is only widely employed in a couple of those: ``Division'' and ``GMPbench, divide''. On the remaining the benchmarks the use is sparse.

Consequently the hypothetical gains in benchmarks scores due to division improvements will be modest. Albeit significant enough to justify its redesign. As explained in section~\ref{sec:div}, a simple division algorithm can be implemented to halve the execution time of the baseline version, without having a hefty power growth.

On the contrary, the multiplication, is extensively used by all types of benchmarks. Moreover, the unit can also be used to calculate addresses by the operating system running on the FPGA board. Therefore improvements in this unit are expected to have a greater impact on the benchmark scores. 

Inspecting the code for the original multiplier we discovered that there are two alternative implementations. The first one relies on the synthesizer to provide the multiplier. This can be defined through the \texttt{infer} generic of the \texttt{mul32}. Obviously this option should only be used if the synthesis tool is capable of inferring an efficient multiplier implementation. In VHDL code this is simply represented as a $*$.

Alternatively there are precompiled components included in the project tree. On the \texttt{mul32} unit they are invoked according to the distinct input sizes 16x16 (\texttt{mul\_17\_17}), 32x8 (\texttt{mul\_33\_9}), 32x16 (\texttt{mul\_33\_17}) and 32x32 (\texttt{mul\_33\_33}).

Therefore the original implementation is opaque to the user and cannot be modified to suit our requirements. For this reason and for total flexibility in the design process we elected to rewrite the multiplier from the ground up.

As explained, reducing the latency of the multiplications can have an important effect on the overall performance of the processor which shall be reflected in the benchmark scores. Moreover since we are targeting the \texttt{power$\times$benchmark} metric we would like to develop a unit that prioritizes performance and power consumption over other aspects, such as area footprint. Having these trade-offs in mind we can proceed to investigate various multiplier schemes. This analysis will be shown later on, in section~\ref{sec:mul}.

In the original design the slowest path of the complete processor, according to the synthesizer, is located in the DRAM controller (from \url{ddrsp0.ddrc0/ddr32.ddrc/ra.raddr_0} to \url{ddrsp0.ddrc0/ddr_phy0/ddr_phy0/xc4v.ddr_phy0/casgen}).

Altering the DRAM to reduce the path is expected to be very arduous. First, because the delay in the circuit is affected by the place\&routing process, so after the re-design of the arithmetic unit this path could change. Second, the documentation is exiguous on the implementation details, moreover the limited available for this project forced us to focus our work on the changes with the highest impact. Therefore we decided to postpone further analysis until we had a working version with the improved arithmetic core in order to see how the slowest path evolved.

About the architecture, there are several different improvements possible.
The baseline version is equipped with a static branch predictor, which can significantly augment performance. Nonetheless even better algorithms exist such as one or two bit branch prediction buffer or correlation prediction.
An improvement in this category may be moderate but present in every kind of benchmark: on average, branches constitute 30\% of all instructions, so the execution time can be significantly reduced.

The static prediction doesn't contemplate heavy calculations, indeed it's very simple so the power consumption in the baseline version due to the prediction is small. Usually more advanced algorithms are employed. For the branch prediction buffer the algorithm consists of a small state machine, but even a small increase can be very significant as more calculations are executed in every fetched branch. Notwithstanding with respect to the execution time we believe the benefits outweigh the costs.

There are others modification that can be done, for example designing a scalable architecture such as Tomasulo's. Still this kind of changes require a deep alteration of the complete architecture. The code for the baseline version of the integer unit is over 3000 lines of code, and therefore it's very unlikely to have a working scalar integer unit in the small time we have for this project. Consequently we decided to allocate our time on other improvements.

In conclusion, we focused the bulk of our efforts on the arithmetic unit since we consider it to be the most efficient way to invest our resources, given the ratio between the possible improvements and the corresponding work required. Further improvements will take place, if time permits, after completing the multiplication and division units.
