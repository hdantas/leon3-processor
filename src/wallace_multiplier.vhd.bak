------------------------------------------------------------------------------
--   
-----------------------------------------------------------------------------
-- Entity: 	r4s-div32
-- File:	r4s-div32.vhd
-- Authors:	Luca Feltrin - Henrique Dantas
-- Description:	This unit implements a divide unit to execute 64-bit by 32-bit
--		division. The divider leaves no remainder.
--		Overflow detection is performed according to the
--		SPARC V8 manual, method B (page 116)
--		Division is made using the radix-4 SRT algorithm 
--  The operands must be stable during
--		the calculations. The result is available one clock after
--		the ready signal is asserted.
------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.all;
-- LIBRARY grlib;
-- USE grlib.stdlib.all;
-- LIBRARY gaisler;
-- USE gaisler.arith.all;

ENTITY wallace_multiplier IS
	GENERIC (
		width : INTEGER := 4;
		stages : INTEGER := 3
	);
	PORT (
		a :	IN STD_LOGIC_VECTOR(width-1 DOWNTO 0);
		b :	IN STD_LOGIC_VECTOR(width-1 DOWNTO 0);
		prod : OUT STD_LOGIC_VECTOR(2*width-1 DOWNTO 0)
	);		
END wallace_multiplier;

ARCHITECTURE behavioral OF wallace_multiplier IS
	-- TYPE layer_depth_type IS ARRAY(32 DOWNTO 3) OF INTEGER;
	-- CONSTANT layer_depth: layer_depth_type := (9,9,9,8,8,8,8,8,8,8,8,8,7,7,7,7,7,7,7,7,7,7,7,7,6,5,5,4,3,3);
	-- CONSTANT stages: INTEGER := layer_depth(width);
	TYPE WallaceTree_type IS ARRAY(2*width-1 DOWNTO 0, width-1 DOWNTO 0,stages-1 DOWNTO 0) OF STD_LOGIC;
	TYPE InitTree_type IS ARRAY(width-1 DOWNTO 0, width-1 DOWNTO 0) OF STD_LOGIC;
	SIGNAL InitTree: InitTree_type; -- Initial product tree
	SIGNAL WallaceTree: WallaceTree_type; -- Wallace tree
	SIGNAL add_a, add_b, add_sum: STD_LOGIC_VECTOR(2*width-1 DOWNTO 0); --for final adder
	SIGNAL c_in: STD_LOGIC := '0';
		
	COMPONENT bk_adder --brent kung adder
		GENERIC (
			width : 	INTEGER := 4
		);
		PORT (
			a :	IN STD_LOGIC_VECTOR(width-1 DOWNTO 0);
			b :	IN STD_LOGIC_VECTOR(width-1 DOWNTO 0);
			c_in :	IN STD_LOGIC;
			sum :	OUT STD_LOGIC_VECTOR(width-1 DOWNTO 0);
			c_out :	OUT STD_LOGIC
		);
	END COMPONENT;	
		
BEGIN --fill multiplier matrix
	partial_proc: PROCESS(a,b)
	BEGIN
		FOR i IN width-1 DOWNTO 0 LOOP
			FOR j IN width-1 DOWNTO 0 LOOP
				WallaceTree(i,j+i,0) <= a(i) AND b(j);
			END LOOP;
		END LOOP;
	END PROCESS;
------------------------------- HERE ---------------------------------------------------------
	
	wallace_proc: PROCESS(WallaceTree,InitTree)
		VARIABLE this_carry_bits: NATURAL := 0;
		VARIABLE num_full_adds: NATURAL := 0;
		VARIABLE num_half_adds: NATURAL := 0;
		VARIABLE num_wires: NATURAL := 0;
		VARIABLE tmp_x: INTEGER := 0;
		VARIABLE tmp_y: INTEGER := 0;
		VARIABLE tmp_cin: INTEGER := 0;
		VARIABLE tmp_cout: INTEGER := 0;
		VARIABLE tmp_s: INTEGER := 0;
	BEGIN --work on the next stages
		FOR k IN 0 TO stages-1 LOOP
			FOR j IN 2*width-1 DOWNTO 0 LOOP
				IF stages = 0 THEN

					IF j = 0 THEN
						WallaceTree(stages+1,0,j) := WallaceTree(stages,0,j);
					
					ELSIF j = 1 THEN
						WallaceTree(stages+1,0:1,j) := WallaceTree(stages,0:1,j);
					
					ELSIF j = 2 THEN
						tmp_x := WallaceTree(stages,0,j);
						tmp_y := WallaceTree(stages,1,j);
						tmp_cin := WallaceTree(stages,2,j);
						tmp_s := WallaceTree(stages+1,0,j);
						tmp_cout := WallaceTree(stages+1,0,j+1);
					
					ELSIF j = 3 THEN
						tmp_x := WallaceTree(stages,0,j);
						tmp_y := WallaceTree(stages,1,j);
						tmp_cin := WallaceTree(stages,2,j);
						tmp_s := WallaceTree(stages+1,1,j);
						tmp_cout := WallaceTree(stages+1,1,j+1);

						WallaceTree(stages+1,2,j) := WallaceTree(stages,3,j);
					
					ELSIF j = 4 THEN
						tmp_x := WallaceTree(stages,1,j);
						tmp_y := WallaceTree(stages,2,j);
						tmp_cin := WallaceTree(stages,3,j);
						tmp_s := WallaceTree(stages+1,0,j);
						tmp_cout := WallaceTree(stages+1,0,j+1);
					
					ELSIF j = 5 THEN
						WallaceTree(stages+1,1:2,j) :=allaceTree(stages,2:3,j);
					
					ELSIF j = 6 THEN
						WallaceTree(stages+1,2,j) := WallaceTree(stages,3,j);
					END IF;

				ELSIF stages = 1 THEN
					IF j = 0 THEN
						WallaceTree(stages+1,0,j) := WallaceTree(stages,0,j);
					
					ELSIF j = 1 THEN
						WallaceTree(stages+1,0:1,j) := WallaceTree(stages,0:1,j);
					
					ELSIF j = 2 THEN
						WallaceTree(stages+1,0,j) := WallaceTree(stages,0,j);
					
					ELSIF j = 3 THEN
						tmp_x := WallaceTree(stages,0,j);
						tmp_y := WallaceTree(stages,1,j);
						tmp_cin := WallaceTree(stages,2,j);
						tmp_s := WallaceTree(stages+1,0,j);
						tmp_cout := WallaceTree(stages+1,0,j+1);
					
					ELSIF j = 4 THEN
						tmp_x := WallaceTree(stages,0,j);
						tmp_y := WallaceTree(stages,1,j);
						tmp_cin := 0;
						tmp_s := WallaceTree(stages+1,1,j);
						tmp_cout := WallaceTree(stages+1,1,j+1);
					
					ELSIF j = 5 THEN
						tmp_x := WallaceTree(stages,0,j);
						tmp_y := WallaceTree(stages,1,j);
						tmp_cin := WallaceTree(stages,2,j);
						tmp_s := WallaceTree(stages+1,0,j);
						tmp_cout := WallaceTree(stages+1,0,j+1);
					
					ELSIF j = 6 THEN
						WallaceTree(stages+1,1,j) := WallaceTree(stages,2,j);
					END IF;
				END IF;

				bit0: FA port map(tmp_x,tmp_y,tmp_cin,tmp_s,tmp_cout); --x,y,cin,s,cout

			END LOOP;
		END LOOP;						
	END PROCESS;
	
	-- Final Adder (Using a Brent Kung Adder)
	signal_vect_proc: PROCESS(W)
	BEGIN
		FOR j IN 2*width-1 DOWNTO 0 LOOP
			add_a(j) <= W(stages-1,0,j);
			add_b(j) <= W(stages-1,1,j);				
		END LOOP;
	END PROCESS;
		
	U_bk_add: bk_adder
	GENERIC MAP (
		width => 2*width
	)
	PORT MAP (
		a => add_a,
		b => add_b,
		c_in => c_in,
		sum => add_sum
	);
	
	prod <= add_sum;
	
END behavioral;
	
	