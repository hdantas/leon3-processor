------------------------------------------------------------------------------
--   
-----------------------------------------------------------------------------
-- Entity: 	r4s-div32
-- File:	r4s-div32.vhd
-- Author:	Luca Feltrin - Henrique Dantas
-- Description:	This unit implemets a divide unit to execute 64-bit by 32-bit
--		division. The divider leaves no remainder.
--		Overflow detection is performed according to the
--		SPARC V8 manual, method B (page 116)
--		Division is made using the radix-4 SRT algorithm with an all-positive p-d plot
--  using carry save format,	and takes ?? clocks. 
--  The operands must be stable during
--		the calculations. The result is available one clock after
--		the ready signal is asserted.
------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
library grlib;
use grlib.stdlib.all;
library gaisler;
use gaisler.arith.all;


entity r4s_div32 is
port (
    rst     : in  std_ulogic;
    clk     : in  std_ulogic;
    holdn   : in  std_ulogic;
    divi    : in  div32_in_type;
    divo    : out div32_out_type
);
end;

architecture rtl of r4s_div32 is

constant Zero34: std_logic_vector(33 downto 0) := "0000000000000000000000000000000000";
constant Zero33: std_logic_vector(32 downto 0) := "000000000000000000000000000000000";

component qSelector is
	port (
		x     	: in  std_logic_vector(65 downto 0);
		d     	: in  std_logic_vector(31 downto 0);
		q    	: out std_logic_vector(2 downto 0)
	);
end component;

component t3to2compressor is
	generic(
		k: integer
	);
	port (
		x     	: in  std_logic_vector(k-1 downto 0);
		y     	: in  std_logic_vector(k-1 downto 0);
		z     	: in  std_logic_vector(k-1 downto 0);
		t   	: in  std_logic;
		s     	: out  std_logic_vector(k downto 0);
		c     	: out  std_logic_vector(k downto 0)
	);
end component;

type div_regtype is record
  state: std_logic_vector(2 downto 0);
  x: std_logic_vector(65 downto 0);
  cnt: std_logic_vector(3 downto 0);
  preshifts: integer;
  d: std_logic_vector(32 downto 0);
end record;

signal r, rin : div_regtype;
signal addin1,addin2: std_logic_vector(34 downto 0);
signal addres: std_logic_vector(33 downto 0);
signal qdigit: std_logic_vector(2 downto 0);
signal a,b: std_logic_vector(33 downto 0);		--input 3-2 compressor
signal t: std_logic;

begin
  divo.result <= addres(31 downto 0);
  
	Qsel: qSelector port map(x=>r.x,d=>r.d(31 downto 0),q=>qdigit);
	
	Comp: t3to2compressor generic map(34) port map(a,b,r.x(65 downto 32),t,addin1,addin2);
	
	SubGen: process(qdigit,r.d)
	begin
		case qdigit is
		when "101" =>	--	-3	3d
			a <= r.d(32) & r.d;
			b <= r.d & '0';
			t <= '0';
		when "110" =>	--	-2	2d
			a <= Zero34;
			b <= r.d & '0';
			t <= '0';
		when "111" =>	--	-1	d
			a <= r.d(32) & r.d;
			b <= Zero34;
			t <= '0';
		when "000" =>	--	0	0d
			a <= Zero34;
			b <= Zero34;
			t <= '0';
		when "001" =>	--	1	-d
			a <= not(r.d(32) & r.d);
			b <= Zero33 & '1';
			t <= '0';
		when "010" =>	--	2	-2d
			a <= Zero34;
			b <= not(r.d) & '0';
			t <= '1';
		when "011" =>	--	3	-3d
			a <= not(r.d(32) & r.d);
			b <= not(r.d) & '1';
			t <= '1';
		when others =>
			a <= Zero34;
			b <= Zero34;
			t <= '0';
		end case;
	end process;

	

  divcomb : process (r, rst, divi,addres)
  variable v : div_regtype;
  begin
    v := r;
    case r.state is
    when "000" =>
      v.cnt := "0000";
      if(divi.start = '1') then
        v.preshifts := 0;
        v.x := divi.y(31 downto 0) & divi.op1(31 downto 0) & "00";  --preshift missing
        v.d := divi.op2;  --preshift missing
        v.state := "001";
      end if;
    when "001" =>
      if r.cnt="1111" then
        v.state := "000";
      else              
        v.x := addres(31 downto 0) & r.x(31 downto 0) & "00";	--shift
		v.cnt := r.cnt + "0001";  
      end if;
    when "010" =>
      v.state := "011";
    when "011" =>
      v.state := "100";
    when "100" =>
      v.state := "101";
    when others =>
      v.state := "000";
    end case;

    rin <= v;
    --divo.result(2 downto 0) <= v.state;

  end process;

  CPA: addres <= addin1(33 downto 0) + addin2(33 downto 0) + t;
  
  reg : process(clk)
  begin 
    if rising_edge(clk) then 
      if (holdn = '1') then r <= rin; end if;
      if (rst = '0') then r.state <= "000";end if;
    end if;
  end process;

end; 

